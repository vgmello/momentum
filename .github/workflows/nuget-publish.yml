name: Publish NuGet Packages

on:
  push:
    tags:
      - 'release'

env:
  DOTNET_VERSION: '9.0.x'

jobs:
  publish:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history needed for version calculation

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Verify on main branch
      run: |
        CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
        if [ "$CURRENT_BRANCH" != "main" ]; then
          echo "Error: Release tag must be created on main branch. Current branch: $CURRENT_BRANCH"
          exit 1
        fi
        echo "✅ Confirmed on main branch"

    - name: Find previous version tag
      id: prev_version
      run: |
        # Find latest regular release tag (excluding pre-releases)
        PREV_TAG=$(git tag -l "v*.*.*" --sort=-v:refname | grep -v 'pre' | head -1)
        if [ -z "$PREV_TAG" ]; then
          echo "No previous regular release tag found, starting from v1.0.0"
          PREV_TAG="v0.0.0"
        fi
        echo "Previous regular release tag: $PREV_TAG"
        echo "prev_tag=$PREV_TAG" >> $GITHUB_OUTPUT

        # Check if there was a pre-release for the current version target
        FILE_VERSION_PREVIEW=$(cat libs/version.txt | tr -d '[:space:]')
        LATEST_PRERELEASE=$(git tag -l "v${FILE_VERSION_PREVIEW}-pre.*" --sort=-v:refname | head -1)

        if [ -n "$LATEST_PRERELEASE" ]; then
          echo "Found pre-release for target version: $LATEST_PRERELEASE"
          echo "This release will transition from pre-release to stable"
          echo "has_prerelease=true" >> $GITHUB_OUTPUT
          echo "latest_prerelease=$LATEST_PRERELEASE" >> $GITHUB_OUTPUT
        else
          echo "has_prerelease=false" >> $GITHUB_OUTPUT
        fi

    - name: Read version file
      id: file_version
      run: |
        if [ ! -f "libs/version.txt" ]; then
          echo "❌ Error: libs/version.txt not found"
          echo "Create this file with a valid semantic version (e.g., '1.0.0')"
          exit 1
        fi

        FILE_VERSION=$(cat libs/version.txt | tr -d '[:space:]')

        if ! [[ $FILE_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "❌ Error: Invalid version format in libs/version.txt: $FILE_VERSION"
          echo "Expected format: X.Y.Z (e.g., '1.2.3')"
          exit 1
        fi

        echo "📋 File version: $FILE_VERSION"
        echo "version=$FILE_VERSION" >> $GITHUB_OUTPUT

    - name: Calculate next version
      id: next_version
      run: |
        FILE_VERSION="${{ steps.file_version.outputs.version }}"
        PREV_TAG="${{ steps.prev_version.outputs.prev_tag }}"
        PREV_VERSION=$(echo $PREV_TAG | sed 's/^v//')
        HAS_PRERELEASE="${{ steps.prev_version.outputs.has_prerelease }}"

        echo "📋 File version: $FILE_VERSION"
        echo "📋 Previous regular release tag: $PREV_TAG (version: $PREV_VERSION)"
        echo "📋 Has pre-releases for target version: $HAS_PRERELEASE"

        # Version comparison function
        version_greater() {
            [ "$(printf '%s\n' "$1" "$2" | sort -V | tail -n1)" = "$1" ]
        }

        if [ "$HAS_PRERELEASE" = "true" ]; then
            # Transitioning from pre-release to stable release
            # Use file version directly (pre-releases were already published for this version)
            NEXT_VERSION="$FILE_VERSION"
            echo "ℹ️  Transitioning from pre-release to stable: $NEXT_VERSION"
            echo "ℹ️  Pre-release sequence will reset after this release"
        elif version_greater "$FILE_VERSION" "$PREV_VERSION"; then
            # Use file version (new version higher than previous release)
            NEXT_VERSION="$FILE_VERSION"
            echo "ℹ️  Using version from libs/version.txt: $NEXT_VERSION (file version > previous tag)"
        else
            # Increment patch from previous tag
            IFS='.' read -r MAJOR MINOR PATCH <<< "$PREV_VERSION"
            NEXT_PATCH=$((PATCH + 1))
            NEXT_VERSION="$MAJOR.$MINOR.$NEXT_PATCH"
            echo "ℹ️  Incrementing patch version: $PREV_VERSION → $NEXT_VERSION (file version ≤ previous tag)"
        fi

        NEXT_TAG="v$NEXT_VERSION"
        echo "📋 Next version: $NEXT_VERSION"
        echo "📋 Next tag: $NEXT_TAG"
        echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        echo "tag=$NEXT_TAG" >> $GITHUB_OUTPUT

    - name: Build packages
      run: |
        echo "🔨 Building all Momentum packages..."
        dotnet build libs/Momentum/src --configuration Release --verbosity minimal

        if [ $? -ne 0 ]; then
          echo "❌ Build failed"
          exit 1
        fi
        echo "✅ Build successful"

    - name: Generate release notes
      id: release_notes
      run: |
        PREV_TAG="${{ steps.prev_version.outputs.prev_tag }}"
        CURRENT_COMMIT=$(git rev-parse HEAD)

        echo "Generating release notes from $PREV_TAG to $CURRENT_COMMIT"

        # Get commit messages between previous tag and current commit
        COMMITS=$(git log --pretty=format:"- %s" ${PREV_TAG}..HEAD)

        # Create release notes
        cat > release_notes.md << EOF
        # Momentum Libraries ${{ steps.next_version.outputs.tag }}

        ## Changes

        $COMMITS

        ## Packages Published

        - Momentum.Extensions
        - Momentum.ServiceDefaults
        - Momentum.Extensions.SourceGenerators
        - Momentum.Extensions.EventDocGenerator
        - Momentum.ServiceDefaults.Api
        - Momentum.Extensions.Abstractions

        All packages are published with version ${{ steps.next_version.outputs.version }}.

        ---

        🤖 Generated with [Claude Code](https://claude.ai/code)
        EOF

        echo "Release notes generated"
        cat release_notes.md

    - name: Create GitHub Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.next_version.outputs.tag }}
        release_name: Momentum Libraries ${{ steps.next_version.outputs.tag }}
        body_path: release_notes.md
        draft: false
        prerelease: false

    - name: Build packages with version
      run: |
        echo "📦 Building packages with version ${{ steps.next_version.outputs.version }}"
        dotnet pack libs/Momentum/src \
          --configuration Release \
          --no-build \
          --verbosity minimal \
          -p:PackageVersion=${{ steps.next_version.outputs.version }}

        echo "✅ Packages built successfully"

    - name: Publish to NuGet
      run: |
        echo "🚀 Publishing packages to NuGet.org..."

        # Find all .nupkg files in the Momentum projects
        PACKAGES=$(find libs/Momentum/src -name "*.nupkg" -not -path "*/bin/Debug/*")

        if [ -z "$PACKAGES" ]; then
          echo "❌ No packages found to publish"
          exit 1
        fi

        echo "Found packages:"
        echo "$PACKAGES"

        # Publish each package
        for package in $PACKAGES; do
          echo "Publishing $package..."
          dotnet nuget push "$package" \
            --api-key ${{ secrets.NUGET_API_KEY }} \
            --source https://api.nuget.org/v3/index.json \
            --skip-duplicate

          if [ $? -eq 0 ]; then
            echo "✅ Successfully published $(basename $package)"
          else
            echo "❌ Failed to publish $(basename $package)"
            exit 1
          fi
        done

        echo "🎉 All packages published successfully!"

    - name: Update release with package info
      run: |
        echo "✅ NuGet packages published successfully"
        echo "📦 All Momentum libraries are now available on NuGet.org with version ${{ steps.next_version.outputs.version }}"
