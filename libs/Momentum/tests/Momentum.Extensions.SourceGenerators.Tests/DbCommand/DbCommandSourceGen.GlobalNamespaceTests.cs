// Copyright (c) Momentum .NET. All rights reserved.

using Momentum.Extensions.SourceGenerators.DbCommand;

namespace Momentum.Extensions.SourceGenerators.Tests.DbCommand;

/// <summary>
/// Tests for DbCommand types in the global namespace, exercising AppendNamespace(sb, null) path
/// and GetFileName with isGlobalNamespace = true.
/// </summary>
public class DbCommandSourceGenGlobalNamespaceTests : DbCommandSourceGenTestsBase
{
    private const string GlobalSourceImports = """
                                               using Momentum.Extensions.Abstractions.Dapper;
                                               using Momentum.Extensions.Abstractions.Messaging;
                                               """;

    [Fact]
    public void GlobalNamespace_ShouldGenerateDbParamsWithoutNamespaceDeclaration()
    {
        // Arrange - A DbCommand type with no namespace
        const string source = """
                              [DbCommand(sp: "get_item")]
                              public partial record GetItemCommand(int ItemId) : ICommand<int>;
                              """;

        // Act
        var (generated, diagnostics) = TestHelpers.GetGeneratedSources<DbCommandSourceGenerator>(GlobalSourceImports + source);

        // Assert
        diagnostics.ShouldNotContain(d => d.Severity == DiagnosticSeverity.Error);
        generated.Length.ShouldBe(2); // DbParams + Handler

        // DbParams file should have header but no namespace declaration
        var dbParamsFile = generated.First(g => g.Contains("IDbParamsProvider"));
        dbParamsFile.ShouldContain("// <auto-generated/>");
        dbParamsFile.ShouldContain("#nullable enable");
        dbParamsFile.ShouldNotContain("namespace ");
    }

    [Fact]
    public void GlobalNamespace_ShouldGenerateHandlerWithoutNamespaceDeclaration()
    {
        // Arrange
        const string source = """
                              [DbCommand(sp: "get_item")]
                              public partial record GetItemCommand(int ItemId) : ICommand<int>;
                              """;

        // Act
        var (generated, diagnostics) = TestHelpers.GetGeneratedSources<DbCommandSourceGenerator>(GlobalSourceImports + source);

        // Assert
        diagnostics.ShouldNotContain(d => d.Severity == DiagnosticSeverity.Error);

        var handlerFile = generated.First(g => g.Contains("HandleAsync"));
        handlerFile.ShouldContain("// <auto-generated/>");
        handlerFile.ShouldNotContain("namespace ");
        handlerFile.ShouldContain("GetItemCommandHandler");
    }

    [Fact]
    public void GlobalNamespace_WithSnakeCase_ShouldGenerateCorrectDbParams()
    {
        // Arrange
        const string source = """
                              [DbCommand(sp: "create_widget", paramsCase: DbParamsCase.SnakeCase)]
                              public partial record CreateWidgetCommand(int WidgetId, string WidgetName) : ICommand<int>;
                              """;

        // Act
        var (generated, diagnostics) = TestHelpers.GetGeneratedSources<DbCommandSourceGenerator>(GlobalSourceImports + source);

        // Assert
        diagnostics.ShouldNotContain(d => d.Severity == DiagnosticSeverity.Error);

        var dbParamsFile = generated.First(g => g.Contains("IDbParamsProvider"));
        dbParamsFile.ShouldNotContain("namespace ");
        dbParamsFile.ShouldContain("widget_id = this.WidgetId");
        dbParamsFile.ShouldContain("widget_name = this.WidgetName");
    }

    [Fact]
    public void GlobalNamespace_WithSqlQuery_ShouldUseGlobalQualifiedTypeName()
    {
        // Arrange - A SQL query in global namespace with custom result type
        const string source = """
                              [DbCommand(sql: "SELECT * FROM widgets WHERE id = @Id")]
                              public partial record GetWidgetQuery(int Id) : ICommand<Widget>;

                              public record Widget(int Id, string Name);
                              """;

        // Act
        var (generated, diagnostics) = TestHelpers.GetGeneratedSources<DbCommandSourceGenerator>(GlobalSourceImports + source);

        // Assert
        diagnostics.ShouldNotContain(d => d.Severity == DiagnosticSeverity.Error);

        var handlerFile = generated.First(g => g.Contains("HandleAsync"));
        handlerFile.ShouldNotContain("namespace ");
        handlerFile.ShouldContain("QueryFirstOrDefaultAsync<global::Widget>");
        handlerFile.ShouldContain("global::GetWidgetQuery command");
    }

    [Fact]
    public void GlobalNamespace_ManualCommand_ShouldGenerateOnlyDbParams()
    {
        // Arrange
        const string source = """
                              [DbCommand]
                              public partial record GlobalManualCommand(int Id) : ICommand<int>;
                              """;

        // Act
        var (generated, diagnostics) = TestHelpers.GetGeneratedSources<DbCommandSourceGenerator>(GlobalSourceImports + source);

        // Assert
        diagnostics.ShouldNotContain(d => d.Severity == DiagnosticSeverity.Error);
        generated.Length.ShouldBe(1); // Only DbParams, no handler
        generated[0].ShouldNotContain("namespace ");
    }

    [Fact]
    public void GlobalNamespace_WithIEnumerableResult_ShouldGenerateQueryAsync()
    {
        // Arrange
        const string source = """
                              [DbCommand(sql: "SELECT * FROM items")]
                              public partial record GetAllItemsQuery() : IQuery<System.Collections.Generic.IEnumerable<Item>>;

                              public record Item(int Id, string Name);
                              """;

        // Act
        var (generated, diagnostics) = TestHelpers.GetGeneratedSources<DbCommandSourceGenerator>(GlobalSourceImports + source);

        // Assert
        diagnostics.ShouldNotContain(d => d.Severity == DiagnosticSeverity.Error);

        var handlerFile = generated.First(g => g.Contains("HandleAsync"));
        handlerFile.ShouldNotContain("namespace ");
        handlerFile.ShouldContain("QueryAsync<global::Item>");
    }
}
